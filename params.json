{"name":"Query Store and Persistent Identifier Prototype","tagline":"The SCAPE query store","body":"# QueryStore and Persistent Identification Modules\r\n\r\n\r\nThis project provides two modules: the QueryStore and the Persistent Identification mockup service. Both components\r\nhave been developed within the [SCAPE project](http://www.scape-project.eu/) in order to facilityte data citation\r\ncapabilities for existing applications. This project provides prototypes for a query store and a identification\r\nservice used by such a service.\r\n\r\n## Background: Data Citation\r\n\r\nSharing research data is becoming increasingly important as it enables peers to validate and reproduce data driven experiments.\r\nAs researchers work with different data sets and highly specific individual subsets, the knowledge how subsets have\r\nbeen created is worth preserving. The most common way of creating a subset of a potentially large data set is to\r\nmake a selection based on filtering out those records which are not needed and only include data which fulfils a\r\ngiven criteria.\r\n\r\n## Enter the QueryStore\r\n\r\nThe generic approach to perform such filter operations is to use either use a query language which allows to describe\r\nwhich data to be included and which records should be omitted. SQL is such a general purpose query language. For\r\nend users, interfaces exist which can hide the complexity of query languages by providing forms where users can\r\nmake their selections visually or by entering appropriate values. The QueryStore stored these queries (thus the name)\r\nand makes them available for later reuse. Whenever a reseacher uses a query (via an interface) in order to create a\r\nsubset, the parameters, their order and the sortings applied can be stored. Based on temporal metadata which is\r\ncollected automatically, the query can be re-executed.\r\n\r\n### Query Store Features:\r\n\r\nThe Query store is implemented in Java and provides an API for the most common Tasks. It uses Hibernate to store the\r\nentities (details below).\r\n\r\n* Create new queries\r\n* Add metadata about users\r\n* Add descriptive text\r\n* Attach the persistent identifier of the data source (details below)\r\n* Generate a persistent identifier for the query itself (details below)\r\n* Append a hash of the result set\r\n* Calculate a hash of the query to detect duplicate queries\r\n* Add arbitrary filters in a key value fashion (e.g. 'instrumentName';'tempreatureSensor'). This is used to mapp the\r\ninterface input fields and their respective values which have been entered.\r\n* Add arbitrary many sortings either in ascending or desceinding order\r\n* Detect query duplicates\r\n* Create timestamps automatically for each insert and update.\r\n* Full audit log.\r\n\r\nYou can initialize the QueryStore by using its API. The QueryStore uses Hibernate to persist the data.\r\n\r\n```java\r\n        // Initialize Query Store\r\n        QueryStoreAPI queryAPI= new QueryStoreAPI();\r\n```\r\nThe package Examples contains usage samples. Read the JavaDocs for more details.\r\n\r\n\r\n\r\n## Persistent Identifaction Service\r\n\r\nIdentifying datasets is essential for future reuse. Storing exported datasets on a Web server and providing the URL\r\nfor its retrieval is not enough. A simle change in the directory structure of the server renders a URL obsolete and\r\nthe dataset can not be retrieved again. Hence a more sophisticated way of referencing datasets is needed. The concept\r\n of [persistent identifiers (PID)](http://en.wikipedia.org/wiki/Persistent_identifier) deals with this problem.\r\n Several different PID systems [exist](http://metadaten-twr.org/2010/10/13/persistent-identifiers-an-overview/) and\r\n they all follow similar principles. A resolver service is introduced which can resolve an identifier to its URL. The\r\n  actual URL may change during the course of time, but the identifier remains always the same (it is persistent).\r\n  Thus whenever a digital object has to be moved to a different location (e.g.. server filesystem updates or similar\r\n  events), its location may be updated and the identifier can then refer to its new location.\r\n\r\n### Persistent Identification Service Features\r\n\r\nThe Query store is implemented in Java and provides an API for the most common Tasks. It uses Hibernate to store the\r\nentities (details below). The following features are currently implemented in the API:\r\n\r\n* Create PIDs of the form *prefix/identifier*.\r\n* Create alphabetical identifiers of arbitrary length (e.g. zjqpU).\r\n* Create alphanumeric identifiers of arbitrary length (YouTube style, eg. qsn4zPVRA7a0).\r\n* Create numeric identifiers of arbitrary length (e.g. 08652).\r\n* Store one URI with each identifier\r\n* Update URIs (the identifier can neither be deleted nor updated via the API)\r\n* Create organizations and prefixes (prefixes are unique).\r\n* One organization can mit arbitrary many identifiers per prefix\r\n* Identifiers are uniqie within one prefix and therefore the complete PID is unique.\r\n* Resolve PIDs to URLs\r\n* Retrieve latest PID pre organization\r\n* Retrieve latest PID in the database.\r\n* Print details\r\n* Full audit log\r\n\r\nYou can initialize the QueryStore by using its API, refer to the examples for getting started. The QueryStore uses\r\nHibernate to persist the data. Details below.\r\n\r\n```java\r\n       PersistentIdentifierAPI api = new PersistentIdentifierAPI();\r\n\r\n\r\n              // create a dummy organization and provide a prefix\r\n              Organization evilOrganization = api.createNewOrganitation(\"Evil Corp\",2345);\r\n              Organization goodOrganization = api.createNewOrganitation(\"Good Company\",6789);\r\n              // set the length for alphanumeric identifiers\r\n              evilOrganization.setAlphanumericPIDlength(20);\r\n              goodOrganization.setAlphanumericPIDlength(12);\r\n\r\n              // create identifiers\r\n              api.getAlphaNumericPID(evilOrganization, \"www.repository.org/collections/datasets/ResearchData.csv\");\r\n              api.getNumericPID(evilOrganization, \"www.repository.org/collections/datasets/QuerySet\");\r\n              api.getAlphaPID(evilOrganization, \"www.repository.org/documentation/manual.pdf\");\r\n```\r\nThe package Examples contains usage samples. Read the JavaDocs for more details.\r\n\r\n\r\n\r\n## Initializing the database\r\n\r\nIn order to use the modules you need to create a database scheme, create a user and add the corresponding permissions\r\n. This shows an example for MySQL. The permissions are not intended to be used in productive environments.\r\n\r\n```sql\r\n\r\nDROP DATABASE IF EXISTS `QueryStore`;\r\nCREATE DATABASE `QueryStore`;\r\n\r\nGRANT ALL PRIVILEGES ON QueryStore.* To 'QUERYSTOREUSER'@'localhost' IDENTIFIED BY 'PASSWORD';\r\nFLUSH PRIVILEGES;\r\n\r\n```\r\n\r\nAfter you have set up and tested the database access, you need to enter the username,\r\nthe password and the database into the Hibernate configuration files called hibernate.cfg.xml in thr folder resources\r\n in each module.\r\n\r\n\r\n ```xml\r\n<property name=\"hibernate.connection.username\">QUERYSTOREUSER</property>\r\n<property name=\"hibernate.connection.password\">PASSWORD</property>\r\n<property name=\"hibernate.connection.url\">jdbc:mysql://localhost:3306/QueryStore</property>\r\n ```\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}